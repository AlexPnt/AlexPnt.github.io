---
title: Speeding up python programs with Numba
date: 2018-09-23 16:21:56
tags:
- python
- development
- performance
---

## When Python is not enough
The Python programming language is a great tool for almost any kind of rapid prototyping and quick development. It has great features such as its high level nature, a syntax with almost human-level readability . Besides, it is cross platform, with a a diverse standard library and it is multi-paradigm, giving a lot of freedom to the programmer which can use different programming paradigms such as [object-oriented](https://en.wikipedia.org/wiki/Object-oriented_programming), [functional](https://en.wikipedia.org/wiki/Functional_programming) or [procedural](https://en.wikipedia.org/wiki/Procedural_programming) as he sees fit. However, sometimes some portion of our system has high performance requirements and thus the speed that Python offers might not be sufficient. So, how can we boost performance without leaving the realm of Python (using for example compiled languages such as C/C++ or JIT/compiled such as JAVA) and when all of our optimizations are not enough anymore ? 

A possible solution is to make use of Numba, a runtime compiler that translates Python code to native instructions, while letting us use the concise and expressiveness power of Python and also achieve native code speed.

## Whats is Numba ?

[Numba](http://numba.pydata.org/) is a library that performs [JIT](https://en.wikipedia.org/wiki/Just-in-time_compilation) compilation, that is, translates pure python code to optimized machine code at runtime, using the [LLVM](https://llvm.org/) industry-standard compiler. It is also able to automatically parallelize loops and run them on multiple cores. Numba is cross-platform since it works on different operative systems (Linux, Windows, OSX) and different architectures (x86, x86_64, ppc64le, etc). It is also able to run the same code on a GPU (Nvidia CUDA or AMD ROC) and is compatible with Python 2.7 and 3.4-3.7. Overall, the most impressive feature is its simplicity of use since we only need a few decorators to leverage the full power of JIT optimizations.

## Numba modes and the @jit decorator

The most important instruction is the *@jit* decorator. It is this decorator that instructs the compiler which mode to run and with what configurations . Under the hood, the generated bytecode of our decorated functions combined with the arguments that we specify in the decorator, such as the type of the input arguments, are analysed, optimized and finally compiled with the LLVM, generating specially tailored native machine instructions for the CPU currently in use. This compiled version is then reused for each function call . 

There are two important modes: *nopython* and *object*. The *nopython* completely avoids the python interpreter and translates the full code to native instructions that can be run without the help of Python . However, if for some reason, that mode is not available (for example, when using unsupported Python features or external libraries) the compilation will fall back to the *object* mode, where it uses the Python interpreter when it is unable to compile some code . Naturally, the *nopython* mode is the one who offers the best performance gains .


## Speeding numerical computations: An example

The best use case where we can make use of the Numba library is when we have to do intensive numerical computations .  
